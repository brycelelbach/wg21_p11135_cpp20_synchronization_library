<!--
Copyright (c) 2018 NVIDIA Corporation 
Author: Bryce Adelstein Lelbach <brycelelbach@gmail.com>

Distributed under the Boost Software License v1.0 (boost.org/LICENSE_1_0.txt)
-->
<pre class='metadata'>
Title: The C++20 Synchronization Library
Shortname: P1135
Revision: 5
Status: P
Group: WG21
Audience: LWG
Editor: Bryce Adelstein Lelbach, NVIDIA, brycelelbach@gmail.com
Editor: Olivier Giroux, NVIDIA, ogiroux@nvidia.com
Editor: JF Bastien, Apple, jfbastien@apple.com
Editor: Detlef Vollmann, dv@vollmann.ch
Editor: David Olsen, NVIDIA, dolsen@nvidia.com
URL: https://wg21.link/P1135R5
!Source: <a href="https://github.com/brycelelbach/wg21_p1135_cpp20_synchronization_library/blob/master/cpp20_synchronization_library.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/brycelelbach/wg21_p1135_cpp20_synchronization_library/issues
Metadata Order: Author, This Version, Source, Issue Tracking, Project, Audience
Markup Shorthands: markdown yes
Toggle Diffs: no
No Abstract: yes
Boilerplate: style-syntax-highlighting off
</pre>

<style>
pre {
  margin-top: 0px;
  margin-bottom: 0px;
}
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}
.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
math, span.math {
  font-family: serif;
  font-style: italic;
}
ul {
  list-style-type: "— ";
}
blockquote {
  counter-reset: paragraph;
}
div.numbered, div.newnumbered {
  margin-left: 2em;
  margin-top: 1em;
  margin-bottom: 1em;
}
div.numbered:before, div.newnumbered:before {
  position: absolute;
  margin-left: -2em;
  display-style: block;
}
div.numbered:before {
  content: counter(paragraph);
  counter-increment: paragraph;
}
div.newnumbered:before {
  content: "�";
}
div.numbered ul, div.newnumbered ul {
  counter-reset: list_item;
}
div.numbered li, div.newnumbered li {
  margin-left: 3em;
}
div.numbered li:before, div.newnumbered li:before {
  position: absolute;
  margin-left: -4.8em;
  display-style: block;
}
div.numbered li:before {
  content: "(" counter(paragraph) "." counter(list_item) ")";
  counter-increment: list_item;
}
div.newnumbered li:before {
  content: "(�." counter(list_item) ")";
  counter-increment: list_item;
}
</style>

# Introduction # {#intro}

This paper is the unification of a series of related C++20 proposals for
introducing new synchronization and thread coordination facilities and
enhancing existing ones:

  - [[P0514R4]]: Efficient `atomic` waiting and semaphores.
  - [[P0666R2]]: Latches and barriers.
  - [[P0995R1]]: `atomic_flag::test` and lockfree integral types.
  - [[P1258R0]]: Don't make C++ unimplementable for small CPUs.

The first part of this paper adds member functions `wait`, `notify_one`,
and `notify_all` to `atomic<T>`.  It does not add those same member
functions to `atomic_ref<T>`, `atomic<shared_ptr<T>>`, or
`atomic<weak_ptr<T>>`.  Those omissions were partly an oversight, because
the papers for those types were in flight at the same time as this paper.
Adding `wait`, `notify_one`, and `notify_all` to the other types are not
being added to this paper, but will be done separately in
<a href="https://wg21.link/P1643">[P1643R0]</a> and
<a href="https://wg21.link/P1644">[P1644R0]</a>.

# Changelog # {#changelog}

**Revision 0:** Post Rapperswil 2018 changes from [[P0514R4]], [[P0666R2]], and [[P0995R1]] based on <a href="http://wiki.edg.com/bin/view/Wg21rapperswil2018/P0666">Rapperswil 2018 LEWG feedback</a>.

  - Refactored `basic_barrier` and `barrier` into one class with a default template parameter as suggested by LEWG at Rapperswil 2018.
  - Refactored `basic_semaphore` and `counting_semaphore` into one class with a default template parameter as suggested by LEWG at Rapperswil 2018.
  - Fixed `update` parameters in semaphore, latch, and barrier member functions to consistently default to 1 to resolve mistakes identified by LEWG at Rapperswil 2018.

**Revision 1:** Pre San Diego 2018 changes based on <a href="http://wiki.edg.com/bin/view/Wg21rapperswil2018/P0666">Rapperswil 2018 LEWG feedback</a> and <a href="http://lists.isocpp.org/lib-ext/2018/06/7755.php">a June discussion on the LEWG and SG1 mailing lists</a>.

  - Added member function versions of `atomic_wait_*` and `atomic_notify_*`, for consistency. Refactored wording to accommodate this.
  - Renamed the `atomic_flag` overloads of `atomic_wait` and `atomic_wait_explicit` to `atomic_flag_wait` and `atomic_flag_wait_explicit` for consistency and to leave the door open for future compatibility with C.
  - Renamed `latch::arrive_and_wait` and `barrier::arrive_and_wait` to `latch::sync` and `barrier::sync`, because LEWG at Rapperswil 2018 expected these methods to be the common use case and prefers they have a short name.
  - Renamed `latch::arrive` to `latch::count_down` to further separate and distinguish the `latch` and `barrier` interfaces.
  - Removed `barrier::try_wait` to resolve concerns raised during LEWG discussion at Rapperswil 2018 regarding its "maybe consuming" nature.
  - Required that `barrier::arrival_token`'s move constructor and move assignment operators are `noexcept` to resolve discussions in LEWG at Rapperswil 2018 regarding exceptions being thrown when using the split arrive and wait barrier interface. 
  - Made `counting_semaphore::acquire`, `counting_semaphore::try_acquire`, and `latch::wait` `noexcept`, because participants in the mailing list discussion preferred that synchronization operations not throw and that any resource acquisition failures be reported by throwing during construction of synchronization objects.
  - Made `counting_semaphore`, `latch`, and `barrier`'s constructors non `constexpr` and allowed them to throw `system_error` if the object cannot be created, because participants in the mailing list discussion preferred that synchronization operations not throw and that any resource acquisition failures be reported by throwing during construction of synchronization objects.
  - Clarified that `counting_semaphore::release`, `latch::count_down`, `latch::sync`, `barrier::wait`, `barrier::sync`, and `barrier::arrive_and_drop` throw nothing (but cannot be `noexcept`, because they have preconditions) to resolve discussions in LEWG at Rapperswil 2018 and on the mailing list.  

**Revision 2:** San Diego 2018 changes to incorporate [[P1258R0]] and pre-meeting feedback.

  - Made `barrier::wait` take its `arrival_token` parameter by rvalue reference.
  - Made the `atomic_signed_lock_free` and `atomic_unsigned_lock_free` types optional for freestanding implementations, as per [[P1258R0]].

**Revision 3:** Pre Kona 2019 changes based on <a href="http://wiki.edg.com/bin/view/Wg21sandiego2018/P1135">San Diego 2018 LEWG feedback</a>.

  - Renamed `latch::sync` and `barrier::sync` back to `latch::arrive_and_wait` and `barrier::arrive_and_wait`, because this name had the strongest consensus in LEWG at San Diego 2018.
  - Removed `atomic_int_fast_wait_t` and `atomic_uint_fast_wait_t`, because LEWG at San Diego 2018 felt that the use case was uncommon and the types had high potential for misuse.
  - Made `counting_semaphore::acquire` and `latch::wait` non `noexcept` again, because LEWG at San Diego 2018 desired `constexpr` constructors for new synchronization objects to allow synchronization during program initialization and to maintain consistency with existing synchronization objects like `mutex`.
  - Made `counting_semaphore`, `latch`, and `barrier`'s constructors `constexpr` again, because LEWG at San Diego 2018 desired `constexpr` constructors for new synchronization objects to allow synchronization during program initialization and to maintain consistency with existing synchronization objects like `mutex`.
  - Clarified that `counting_semaphore::release`, `latch::count_down`, `latch::arrive_and_wait`, `barrier::wait`, `barrier::arrive_and_wait`, and `barrier::arrive_and_drop` may throw `system_error` exceptions, which is an implication of the constructors of said objects being `constexpr` because any underlying system errors must be reported on operations not during construction.
  - Added missing `atomic<T>::wait` and `atomic<T>::notify_*` member functions to the class synopses for the `atomic<T>` integral, floating-point, and pointer specializations.
  - Fixed `atomic<T>::notify_*` member functions to be non `const`.

**Revision 4:** Lots of wording changes based on <a href="http://wiki.edg.com/bin/view/Wg21kona2019/LWG1135Notes">Kona 2019 LWG feedback</a>.  Three design changes to fix bugs that were discovered during LWG review or afterwards while revising the paper.  These will be presented to SG1 in a separate paper, [[P1633R0]], in Cologne.

  - Changed `atomic_flag::test` to be a `const` function.  Changed the `atomic_flag*` parameter of `atomic_flag_test` and `atomic_flag_test_explicit` to be `const atomic_flag*`.
  - Added the requirement that the `least_max_value` template parameter to `counting_semaphore` be greater than zero.
  - Changed the requirement on the `update` parameter to `barrier::arrive` from `update >= 0` to `update > 0`.

**Revision 5:** Some wording improvements after the post-Kona mailing
and before the pre-Cologne mailing.
Incorporated feedback from LWG teleconferences on <a href="http://wiki.edg.com/bin/view/Wg21cologne2019/LWGTelecom7June">7 June</a> and <a href="http://wiki.edg.com/bin/view/Wg21cologne2019/LWGTelecom14June">14 June</a>.
Rebased the wording to be relative to the post-Kona draft, [[N4810]].
There is one design change, which will be included in <a href="https://wg21.link/P1633R0">[P1633R0]</a> along with the three changes in R4:

  - Allow `latch::try_wait` to spuriously return `false`.

# Wording # {#wording}

Note: The following changes are relative to the post Kona 2019 working draft of ISO/IEC 14882, ([[N4810]]).

Note: The � character is used to denote a placeholder number which shall be selected by the editor.

Add `<semaphore>`, `<latch>`, and `<barrier>` to <a href="http://eel.is/c++draft/headers#tab:headers.cpp">Table 19</a> "C++ library headers" in <a href="http://eel.is/c++draft/headers">[**headers**]</a>.

Modify paragraph 3 in <a href="http://eel.is/c++draft/compliance">16.5.1.3
[**compliance**]</a> as follows:

<blockquote><div>
The supplied version of the header `<cstdlib>` shall declare at least the functions `abort`, `atexit`, `at_quick_exit`, `exit`, and `quick_exit` (<a href="http://eel.is/c++draft/support.start.term">17.5</a>). <ins>The supplied version of the header `<atomic>` shall meet the same requirements as for a hosted implementation except that support for always lock-free integral atomic types (<a href="http://eel.is/c++draft/atomics.lockfree">[**atomics.lockfree**]</a>) is optional, and the type aliases `atomic_signed_lock_free` and `atomic_unsigned_lock_free` (<a href="http://eel.is/c++draft/atomics.alias">[**atomics.alias**]</a>) are optional.</ins> The other headers listed in this table shall meet the same requirements as for a hosted implementation.
</div></blockquote>

Modify the header synopsis for `<atomic>` in <a href="http://eel.is/c++draft/atomics.syn">[**atomics.syn**]</a> as follows:

<blockquote>
<b>31.2 Header `<atomic>` synopsis <span style="float: right;">[atomics.syn]</span></b>

<pre><code>
namespace std {
  <i>// ...</i>
  
  <i>// 31.8, non-member functions</i>
  <i>// ...</i>

</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_wait(const volatile atomic&lt;T&gt;*, </code></pre>
<pre class="ins"><code>                     typename atomic&lt;T&gt;::value_type);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_wait(const atomic&lt;T&gt;*,</code></pre>
<pre class="ins"><code>                     typename atomic&lt;T&gt;::value_type);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_wait_explicit(const volatile atomic&lt;T&gt;*, </code></pre>
<pre class="ins"><code>                              typename atomic&lt;T&gt;::value_type, </code></pre>
<pre class="ins"><code>                              memory_order);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_wait_explicit(const atomic&lt;T&gt;*, </code></pre>
<pre class="ins"><code>                              typename atomic&lt;T&gt;::value_type,</code></pre>
<pre class="ins"><code>                              memory_order);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_notify_one(volatile atomic&lt;T&gt;*);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_notify_one(atomic&lt;T&gt;*);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_notify_all(volatile atomic&lt;T&gt;*);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_notify_all(atomic&lt;T&gt;*);</code></pre>
<pre><code>
&nbsp;
&nbsp; <i>// 31.3, type aliases</i>
  <i>// ...</i>
   
  using atomic_intptr_t       = atomic&lt;intptr_t&gt;;
  using atomic_uintptr_t      = atomic&lt;uintptr_t&gt;;
  using atomic_size_t         = atomic&lt;size_t&gt;;
  using atomic_ptrdiff_t      = atomic&lt;ptrdiff_t&gt;;
  using atomic_intmax_t       = atomic&lt;intmax_t&gt;;
  using atomic_uintmax_t      = atomic&lt;uintmax_t&gt;;
 
</code></pre>
<pre class="ins"><code>  using atomic_signed_lock_free   = <i>see below</i>;</code></pre>
<pre class="ins"><code>  using atomic_unsigned_lock_free = <i>see below</i>;</code></pre>
<pre><code>
&nbsp;

  <i>// 31.9, flag type and operations</i>
  struct atomic_flag;
</code></pre>
<ins><xmp>
  bool atomic_flag_test(const volatile atomic_flag*) noexcept;
  bool atomic_flag_test(const atomic_flag*) noexcept;
  bool atomic_flag_test_explicit(const volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_explicit(const atomic_flag*, memory_order) noexcept;
</xmp></ins>
<pre><code>
&nbsp; bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
</code></pre>
<pre class="ins"><code>  void atomic_flag_wait(const volatile atomic_flag*, bool) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_wait(const atomic_flag*, bool) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_wait_explicit(const volatile atomic_flag*,</code></pre>
<pre class="ins"><code>                                 bool, memory_order) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_wait_explicit(const atomic_flag*,</code></pre>
<pre class="ins"><code>                                 bool, memory_order) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_notify_one(volatile atomic_flag*) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_notify_one(atomic_flag*) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_notify_all(volatile atomic_flag*) const noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_notify_all(atomic_flag*) const noexcept;</code></pre>
<pre><code>
&nbsp; #define ATOMIC_FLAG_INIT <i>see below</i>

  <i>// 30.10, fences</i>
  extern "C" void atomic_thread_fence(memory_order) noexcept;
  extern "C" void atomic_signal_fence(memory_order) noexcept;
}
</code></pre>
</blockquote>

Modify <a href="http://eel.is/c++draft/atomics.alias">[**atomics.alias**]</a> as follows, adding a new paragraph to the end:

<blockquote>
<b>31.3 Type aliases <span style="float: right;">[atomics.alias]</span></b>

<div class="numbered">
The type aliases `atomic_intN_t`, `atomic_uintN_t`, `atomic_intptr_t`, and `atomic_uintptr_t` are defined if and only if `intN_t`, `uintN_t`, `intptr_t`, and `uintptr_t` are defined, respectively.
</div>

<div class="ins">
<div class="numbered">
The type aliases `atomic_signed_lock_free` and `atomic_unsigned_lock_free` name specializations of `atomic` whose template arguments are integral types, respectively signed and unsigned, and whose `is_always_lock_free` property is `true`. [ *Note*: These aliases are optional in freestanding implementations (<a href="http://eel.is/c++draft/compliance">[**compliance**]</a>). - *end note* ] Implementations should choose for these aliases the integral specializations of atomic for which the atomic waiting and notifying operations ([**atomics.wait**]) are most efficient.
</div>
</div>
</blockquote>

Insert a new paragraph after paragraph 1 in <a href="http://eel.is/c++draft/atomics.lockfree">[**atomics.lockfree**]</a>:

<blockquote class="ins">
At least one signed integral specialization of the `atomic` template, along with the specialization for the corresponding unsigned type (<a href="http://eel.is/c++draft/basic.fundamental">[**basic.fundamental**]</a>), shall be always lock-free. [ *Note*: This requirement is optional in freestanding implementations (<a href="http://eel.is/c++draft/compliance">[**compliance**]</a>). - *end note* ]
</blockquote>

Add a new subclause after <a href="http://eel.is/c++draft/atomics.lockfree">[**atomics.lockfree**] with the stable name [**atomics.wait**]</a>:

<blockquote class="ins">
<b>31.� Waiting and notifying <span style="float: right;">[atomics.wait]</span></b>

<div class="numbered">
<dfn>Atomic waiting operations</dfn> and <dfn>atomic notifying operations</dfn> provide a mechanism to wait for the value of an atomic object to change more efficiently than can be achieved with polling.
Atomic waiting operations may block until they are unblocked by atomic notifying operations, according to each function’s effects.
[ *Note:* Programs are not guaranteed to observe transient atomic values, an issue known as the A-B-A problem, resulting in continued blocking if a condition is only temporarily met. – *end note* ]
</div>

<div class="numbered">
[ *Note*: The following functions are atomic waiting operations:

  - `atomic<T>::wait`.
  - `atomic_flag::wait`.
  - `atomic_wait` and `atomic_wait_explicit`.
  - `atomic_flag_wait` and `atomic_flag_wait_explicit`.

*- end note* ]
</div>

<div class="numbered">
[ *Note*: The following functions are atomic notifying operations:

  - `atomic<T>::notify_one` and `atomic<T>::notify_all`.
  - `atomic_flag::notify_one` and `atomic_flag::notify_all`.
  - `atomic_notify_one` and `atomic_notify_all`.
  - `atomic_flag_notify_one` and `atomic_flag_notify_all`.

*- end note* ]
</div>

<div class="numbered">
A call to an atomic waiting operation on an atomic object `M` is <dfn>eligible to be unblocked</dfn> by a call to an atomic notifying operation on `M` if there exist side effects `X` and `Y` on `M` such that:
  - the atomic waiting operation has blocked after observing the result of `X`,
  - `X` precedes `Y` in the modification order of `M`, and
  - `Y` happens before the call to the atomic notifying operation.
</div>
</blockquote>

Drafting note: Adding atomic waiting and notifying operations to `atomic_ref<T>` and to `atomic<shared_ptr<T>>` is done in separate papers, <a href="https://wg21.link/P1643">[P1643R0]</a> and <a href="https://wg21.link/P1644">[P1644R0]</a> respectively, not as part of this paper.

Modify <a href="http://eel.is/c++draft/atomics.types.generic">[**atomics.types.generic**]</a> as follows:

<blockquote>
<b>31.7 Class template `atomic` <span style="float: right;">[atomics.types.generic]</span></b>

<pre><code>
namespace std {
  template&lt;class T&gt; struct atomic {
    using value_type = T;
    static constexpr bool is_always_lock_free = <i>implementation-defined</i>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(T, memory_order = memory_order::seq_cst) noexcept;
    T load(memory_order = memory_order::seq_cst) const volatile noexcept;
    T load(memory_order = memory_order::seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    T exchange(T, memory_order = memory_order::seq_cst) volatile noexcept;
    T exchange(T, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T&amp;, T,
                               memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T,
                               memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(T&amp;, T,
                                 memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T,
                                 memory_order = memory_order::seq_cst) noexcept;
</code></pre>
<pre class="ins"><code>    void wait(T, memory_order = memory_order::seq_cst) const volatile noexcept;</code></pre>
<pre class="ins"><code>    void wait(T, memory_order = memory_order::seq_cst) const noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() noexcept;</code></pre>
<pre><code>
&nbsp;   atomic() noexcept = default;
    constexpr atomic(T) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;
  };
}
</code></pre>
</blockquote>

Drafting note: The behavior of the non-member functions `atomic_wait`, `atomic_wait_explicit`, `atomic_notify_one`, and `atomic_notify_all` is already covered by <a href="http://eel.is/c++draft/atomics.nonmembers">[**atomics.nonmembers**]</a>.  Only the behavior of the member functions needs to be listed here.

Add the following to the end of <a href="http://eel.is/c++draft/atomics.types.operations">[**atomics.types.operations**]</a>:

<blockquote class="ins">
```
void wait(T old, memory_order order = memory_order::seq_cst) const volatile noexcept;
void wait(T old, memory_order order = memory_order::seq_cst) const noexcept;
```

<div class="numbered">
*Expects:* `order` is neither `memory_order::release` nor `memory_order::acq_rel`.
</div>

<div class="numbered">
*Effects:* Repeatedly performs the following steps, in order: 

  - Evaluates `load(order)` and compares its value representation for equality against that of `old`.
  - If they compare unequal, returns.
  - Blocks until it is unblocked by an atomic notifying operation or is unblocked spuriously.

</div>

<div class="numbered">
*Remarks:* This function is an atomic waiting operation ([**atomics.wait**]).
</div>

```
void notify_one() volatile noexcept;
void notify_one() noexcept;
```

<div class="numbered">
*Effects:* Unblocks the execution of at least one atomic waiting operation that is eligible to be unblocked ([**atomics.wait**]) by this call, if any such atomic waiting operations exist.
</div>

<div class="numbered">
*Remarks:* This function is an atomic notifying operation ([**atomics.wait**]).
</div>

```
void notify_all() volatile noexcept;
void notify_all() noexcept;
```

<div class="numbered">
*Effects:* Unblocks the execution of all atomic waiting operations that are eligible to be unblocked ([**atomics.wait**]) by this call.
</div>

<div class="numbered">
*Remarks:* This function is an atomic notifying operation ([**atomics.wait**]).
</div>
</blockquote>

Modify <a href="http://eel.is/c++draft/atomics.types.int#1">[**atomics.types.int**] paragraph 1</a> as follows:

<blockquote>
<b>31.7.2 Specializations for integers <span style="float: right;">[atomics.types.int]</span></b>

<div class="numbered">
There are specializations of the `atomic` class template for the integral types `char`, `signed char`, `unsigned char`, `short`, `unsigned short`, `int`, `unsigned int`, `long`, `unsigned long`, `long long`, `unsigned long long`, `char8_t`, `char16_t`, `char32_t`, `wchar_t`, and any other types needed by the typedefs in the header `<cstdint>`.
For each such type <code><i>integral</i></code>, the specialization <code>atomic&lt;<i>integral</i>&gt;</code> provides additional atomic operations appropriate to integral types.
[ *Note:* For the specialization `atomic<bool>`, see <a href="http://eel.is/c++draft/atomics.types.generic">31.7</a>. — *end note* ]
</div>

<pre><code>
namespace std {
  template&lt;&gt; struct atomic&lt;<i>integral</i>&gt; {
    using value_type = <i>integral</i>;
    using difference_type = value_type;
    static constexpr bool is_always_lock_free = <i>implementation-defined</i>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(<i>integral</i>, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(<i>integral</i>, memory_order = memory_order::seq_cst) noexcept;
    <i>integral</i> load(memory_order = memory_order::seq_cst) const volatile noexcept;
    <i>integral</i> load(memory_order = memory_order::seq_cst) const noexcept;
    operator <i>integral</i>() const volatile noexcept;
    operator <i>integral</i>() const noexcept;
    <i>integral</i> exchange(<i>integral</i>, memory_order = memory_order::seq_cst) volatile noexcept;
    <i>integral</i> exchange(<i>integral</i>, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(<i>integral</i>&amp;, <i>integral</i>,
                               memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(<i>integral</i>&amp;, <i>integral</i>,
                               memory_order, memory_order) noexcept;
    bool compare_exchange_strong(<i>integral</i>&amp;, <i>integral</i>,
                                 memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(<i>integral</i>&amp;, <i>integral</i>,
                                 memory_order, memory_order) noexcept;
    bool compare_exchange_weak(<i>integral</i>&amp;, <i>integral</i>,
                               memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(<i>integral</i>&amp;, <i>integral</i>,
                               memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(<i>integral</i>&amp;, <i>integral</i>,
                                 memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(<i>integral</i>&amp;, <i>integral</i>,
                                 memory_order = memory_order::seq_cst) noexcept;
</code></pre>
<pre class="ins"><code>    void wait(<i>integral</i>, memory_order = memory_order::seq_cst) const volatile noexcept;</code></pre>
<pre class="ins"><code>    void wait(<i>integral</i>, memory_order = memory_order::seq_cst) const noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() noexcept;</code></pre>
<pre><code>
&nbsp;   <i>integral</i> fetch_add(<i>integral</i>, memory_order = memory_order::seq_cst) volatile noexcept;
    <i>integral</i> fetch_add(<i>integral</i>, memory_order = memory_order::seq_cst) noexcept;
    <i>integral</i> fetch_sub(<i>integral</i>, memory_order = memory_order::seq_cst) volatile noexcept;
    <i>integral</i> fetch_sub(<i>integral</i>, memory_order = memory_order::seq_cst) noexcept;
    <i>integral</i> fetch_and(<i>integral</i>, memory_order = memory_order::seq_cst) volatile noexcept;
    <i>integral</i> fetch_and(<i>integral</i>, memory_order = memory_order::seq_cst) noexcept;
    <i>integral</i> fetch_or(<i>integral</i>, memory_order = memory_order::seq_cst) volatile noexcept;
    <i>integral</i> fetch_or(<i>integral</i>, memory_order = memory_order::seq_cst) noexcept;
    <i>integral</i> fetch_xor(<i>integral</i>, memory_order = memory_order::seq_cst) volatile noexcept;
    <i>integral</i> fetch_xor(<i>integral</i>, memory_order = memory_order::seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(<i>integral</i>) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    <i>integral</i> operator=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator=(<i>integral</i>) noexcept;

    <i>integral</i> operator++(int) volatile noexcept;
    <i>integral</i> operator++(int) noexcept;
    <i>integral</i> operator--(int) volatile noexcept;
    <i>integral</i> operator--(int) noexcept;
    <i>integral</i> operator++() volatile noexcept;
    <i>integral</i> operator++() noexcept;
    <i>integral</i> operator--() volatile noexcept;
    <i>integral</i> operator--() noexcept;
    <i>integral</i> operator+=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator+=(<i>integral</i>) noexcept;
    <i>integral</i> operator-=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator-=(<i>integral</i>) noexcept;
    <i>integral</i> operator&amp;=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator&amp;=(<i>integral</i>) noexcept;
    <i>integral</i> operator|=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator|=(<i>integral</i>) noexcept;
    <i>integral</i> operator^=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator^=(<i>integral</i>) noexcept;
  };
}
</code></pre>
</blockquote>

Modify <a href="http://eel.is/c++draft/atomics.types.float#1">[**atomics.types.float**] paragraph 1</a> as follows:

<blockquote>
<b>31.7.3 Specializations for floating-point types <span style="float: right;">[atomics.types.float]</span></b>

<div class="numbered">
There are specializations of the `atomic` class template for the floating-point types `float`, `double`, and `long double`.
For each such type <code><i>floating-point</i></code>, the specialization <code>atomic&lt;<i>floating-point</i>&gt;</code> provides additional atomic operations appropriate to floating-point types.
</div>

<pre><code>
namespace std {
  template&lt;&gt; struct atomic&lt;<i>floating-point</i>&gt; {
    using value_type = <i>floating-point</i>;
    using difference_type = value_type;
    static constexpr bool is_always_lock_free = <i>implementation-defined</i>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(<i>floating-point</i>, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(<i>floating-point</i>, memory_order = memory_order::seq_cst) noexcept;
    <i>floating-point</i> load(memory_order = memory_order::seq_cst) const volatile noexcept;
    <i>floating-point</i> load(memory_order = memory_order::seq_cst) const noexcept;
    operator <i>floating-point</i>() const volatile noexcept;
    operator <i>floating-point</i>() const noexcept;
    <i>floating-point</i> exchange(<i>floating-point</i>,
                             memory_order = memory_order::seq_cst) volatile noexcept;
    <i>floating-point</i> exchange(<i>floating-point</i>,
                             memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(<i>floating-point</i>&amp;, <i>floating-point</i>,
                               memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(<i>floating-point</i>&amp;, <i>floating-point</i>,
                               memory_order, memory_order) noexcept;
    bool compare_exchange_strong(<i>floating-point</i>&amp;, <i>floating-point</i>,
                                 memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(<i>floating-point</i>&amp;, <i>floating-point</i>,
                                 memory_order, memory_order) noexcept;
    bool compare_exchange_weak(<i>floating-point</i>&amp;, <i>floating-point</i>,
                               memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(<i>floating-point</i>&amp;, <i>floating-point</i>,
                               memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(<i>floating-point</i>&amp;, <i>floating-point</i>,
                                 memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(<i>floating-point</i>&amp;, <i>floating-point</i>,
                                 memory_order = memory_order::seq_cst) noexcept;
</code></pre>
<pre class="ins"><code>    void wait(<i>floating-point</i>,</code></pre>
<pre class="ins"><code>              memory_order = memory_order::seq_cst) const volatile noexcept;</code></pre>
<pre class="ins"><code>    void wait(<i>floating-point</i>,</code></pre>
<pre class="ins"><code>              memory_order = memory_order::seq_cst) const noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() noexcept;</code></pre>
<pre><code>
&nbsp;
    <i>floating-point</i> fetch_add(<i>floating-point</i>,
                             memory_order = memory_order::seq_cst) volatile noexcept;
    <i>floating-point</i> fetch_add(<i>floating-point</i>,
                             memory_order = memory_order::seq_cst) noexcept;
    <i>floating-point</i> fetch_sub(<i>floating-point</i>,
                             memory_order = memory_order::seq_cst) volatile noexcept;
    <i>floating-point</i> fetch_sub(<i>floating-point</i>,
                             memory_order = memory_order::seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(<i>floating-point</i>) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    <i>floating-point</i> operator=(<i>floating-point</i>) volatile noexcept;
    <i>floating-point</i> operator=(<i>floating-point</i>) noexcept;

    <i>floating-point</i> operator+=(<i>floating-point</i>) volatile noexcept;
    <i>floating-point</i> operator+=(<i>floating-point</i>) noexcept;
    <i>floating-point</i> operator-=(<i>floating-point</i>) volatile noexcept;
    <i>floating-point</i> operator-=(<i>floating-point</i>) noexcept;
  };
}
</code></pre>
</blockquote>

Modify <a href="http://eel.is/c++draft/atomics.types.pointer#1">[**atomics.types.pointer**] paragraph 1</a> as follows:

<blockquote>
<b>31.7.4 Partial specialization for pointers <span style="float: right;">[atomics.types.pointer]</span></b>

<pre><code>
namespace std {
  template&lt;class T&gt; struct atomic&lt;T*&gt; {
    using value_type = T*;
    using difference_type = ptrdiff_t;
    static constexpr bool is_always_lock_free = <i>implementation-defined</i>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T*, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(T*, memory_order = memory_order::seq_cst) noexcept;
    T* load(memory_order = memory_order::seq_cst) const volatile noexcept;
    T* load(memory_order = memory_order::seq_cst) const noexcept;
    operator T*() const volatile noexcept;
    operator T*() const noexcept;
    T* exchange(T*, memory_order = memory_order::seq_cst) volatile noexcept;
    T* exchange(T*, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T*&amp;, T*,
                               memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*,
                               memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(T*&amp;, T*,
                                 memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*,
                                 memory_order = memory_order::seq_cst) noexcept;
</code></pre>
<pre class="ins"><code>    void wait(T*, memory_order = memory_order::seq_cst) const volatile noexcept;</code></pre>
<pre class="ins"><code>    void wait(T*, memory_order = memory_order::seq_cst) const noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() noexcept;</code></pre>
<pre><code>
&nbsp;   T* fetch_add(ptrdiff_t, memory_order = memory_order::seq_cst) volatile noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order::seq_cst) noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order::seq_cst) volatile noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order::seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T*) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T* operator=(T*) volatile noexcept;
    T* operator=(T*) noexcept;

    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;
    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator+=(ptrdiff_t) volatile noexcept;
    T* operator+=(ptrdiff_t) noexcept;
    T* operator-=(ptrdiff_t) volatile noexcept;
    T* operator-=(ptrdiff_t) noexcept;
  };
}
</code></pre>

<div class="numbered">
There is a partial specialization of the `atomic` class template for pointers.
Specializations of this partial specialization are standard-layout structs.
They each have a trivial default constructor and a trivial destructor.
</div>
</blockquote>

Modify <a href="http://eel.is/c++draft/atomics.flag">[**atomics.flag**]</a> as follows:

<blockquote>
<b>31.9 Flag type and operations <span style="float: right;">[atomics.flag]</span></b>

<xmp>
namespace std {
  struct atomic_flag {
</xmp>
<ins><xmp>
    bool test(memory_order = memory_order::seq_cst) const volatile noexcept;
    bool test(memory_order = memory_order::seq_cst) const noexcept;
</xmp></ins>
<pre><code>
&nbsp;   bool test_and_set(memory_order = memory_order::seq_cst) volatile noexcept;
    bool test_and_set(memory_order = memory_order::seq_cst) noexcept;
    void clear(memory_order = memory_order::seq_cst) volatile noexcept;
    void clear(memory_order = memory_order::seq_cst) noexcept;
</code></pre>
<pre class="ins"><code>    void wait(bool, memory_order = memory_order::seq_cst) const volatile noexcept;</code></pre>
<pre class="ins"><code>    void wait(bool, memory_order = memory_order::seq_cst) const noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() noexcept;</code></pre>
<pre><code>
&nbsp;
&nbsp;   atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&amp;) = delete;
    atomic_flag&amp; operator=(const atomic_flag&amp;) = delete;
    atomic_flag&amp; operator=(const atomic_flag&amp;) volatile = delete;
  };
 
</code></pre>
<ins><xmp>
  bool atomic_flag_test(const volatile atomic_flag*) noexcept;
  bool atomic_flag_test(const atomic_flag*) noexcept;
  bool atomic_flag_test_explicit(const volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_explicit(const atomic_flag*, memory_order) noexcept;
</xmp></ins>
<pre><code>
&nbsp; bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
</code></pre>
<ins><xmp>
  void atomic_flag_wait(const volatile atomic_flag*, bool) noexcept;
  void atomic_flag_wait(const atomic_flag*, bool) noexcept;
  void atomic_flag_wait_explicit(const volatile atomic_flag*, 
                                 bool, memory_order) noexcept;
  void atomic_flag_wait_explicit(const atomic_flag*, 
                                 bool, memory_order) noexcept;
  void atomic_flag_notify_one(volatile atomic_flag*) noexcept;
  void atomic_flag_notify_one(atomic_flag*) noexcept;
  void atomic_flag_notify_all(volatile atomic_flag*) const noexcept;
  void atomic_flag_notify_all(atomic_flag*) const noexcept;
</xmp></ins>
<pre><code>
&nbsp;
&nbsp; #define ATOMIC_FLAG_INIT <i>see below</i>
</code></pre>
<xmp>
}
</xmp>

<div class="numbered">
The `atomic_flag` type provides the classic test-and-set functionality. It has two states, set and clear.
</div>

<div class="numbered">
Operations on an object of type `atomic_flag` shall be lock-free.
[ *Note:* Hence the operations should also be address-free. — *end note* ]
</div>

<div class="numbered">
The `atomic_flag` type is a standard-layout struct. It has a trivial default
constructor and a trivial destructor.
</div>

<div class="numbered">
The macro `ATOMIC_FLAG_INIT` shall be defined in such a way that it can be used to initialize an object of type `atomic_flag` to the clear state.
The macro can be used in the form:

<xmp>atomic_flag guard = ATOMIC_FLAG_INIT;</xmp>

It is unspecified whether the macro can be used in other initialization contexts.
For a complete static-duration object, that initialization shall be static.
Unless initialized with `ATOMIC_FLAG_INIT`, it is unspecified whether an `atomic_flag` object has an initial state of set or clear.
</div>

<div class="ins">
<xmp>
   bool atomic_flag_test(const volatile atomic_flag* object) noexcept;
   bool atomic_flag_test(const atomic_flag* object) noexcept;
   bool atomic_flag_test_explicit(const volatile atomic_flag* object,
                                  memory_order order) noexcept;
   bool atomic_flag_test_explicit(const atomic_flag* object,
                                  memory_order order) noexcept;
   bool atomic_flag::test(memory_order order =
                            memory_order::seq_cst) const volatile noexcept;
   bool atomic_flag::test(memory_order order =
                            memory_order::seq_cst) const noexcept;
</xmp>

<div class="numbered">
For `atomic_flag_test`, let `order` be `memory_order::seq_cst`.
</div>

<div class="numbered">
*Expects:* `order` is neither `memory_order::release` nor `memory_order::acq_rel`.
</div>

<div class="numbered">
*Effects:* Memory is affected according to the value of `order`.
</div>

<div class="numbered">
*Returns:* Atomically returns the value pointed to by `object` or `this`.
</div>
</div>

<xmp>
   bool atomic_flag_test_and_set(volatile atomic_flag* object) noexcept;
   bool atomic_flag_test_and_set(atomic_flag* object) noexcept;
   bool atomic_flag_test_and_set_explicit(volatile atomic_flag* object,
                                          memory_order order) noexcept;
   bool atomic_flag_test_and_set_explicit(atomic_flag* object,
                                          memory_order order) noexcept;
   bool atomic_flag::test_and_set(memory_order order =
                                    memory_order::seq_cst) volatile noexcept;
   bool atomic_flag::test_and_set(memory_order order =
                                    memory_order::seq_cst) noexcept;
</xmp>

<div class="numbered">
*Effects:* Atomically sets the value pointed to by `object` or by `this` to `true`.
Memory is affected according to the value of `order`.
These operations are atomic read-modify-write operations (4.7).
</div>

<div class="numbered">
*Returns:* Atomically, the value of the object immediately before the effects.
</div>

<xmp>
void atomic_flag_clear(volatile atomic_flag* object) noexcept;
void atomic_flag_clear(atomic_flag* object) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag* object,
                                memory_order order) noexcept;
void atomic_flag_clear_explicit(atomic_flag* object,
                                memory_order order) noexcept;
void atomic_flag::clear(memory_order order =
                          memory_order::seq_cst) volatile noexcept;
void atomic_flag::clear(memory_order order = 
                          memory_order::seq_cst) noexcept;
</xmp>

*Expects:* `order` is neither `memory_order::consume`, `memory_order::acquire`, nor `memory_order::acq_rel`.

*Effects:* Atomically sets the value pointed to by `object` or by `this` to
`false`. Memory is affected according to the value of `order`.

<div class="ins">
<xmp>
void atomic_flag_wait(const volatile atomic_flag* object, bool old) noexcept;
void atomic_flag_wait(const atomic_flag* object, bool old) noexcept;
void atomic_flag_wait_explicit(const volatile atomic_flag* object,
                               bool old, memory_order order) noexcept;
void atomic_flag_wait_explicit(const atomic_flag* object,
                               bool old, memory_order order) noexcept;
void atomic_flag::wait(bool old, memory_order order =
                         memory_order::seq_cst) const volatile noexcept;
void atomic_flag::wait(bool old, memory_order order =
                         memory_order::seq_cst) const noexcept;
</xmp>

<div class="numbered">
For `atomic_flag_wait`, let `order` be `memory_order::seq_cst`.  Let `flag` be `object` for the non-member functions and `this` for the member functions.
</div>

<div class="numbered">
*Expects:* `order` is neither `memory_order::release` nor `memory_order::acq_rel`.
</div>

<div class="numbered">
*Effects:* Repeatedly performs the following steps, in order:

  - Evaluates `flag->test(order) != old`.
  - If the result of that evaluation is `true`, returns.
  - Blocks until it is unblocked by an atomic notifying operation or is unblocked spuriously.

</div>

<div class="numbered">
*Remarks:* This function is an atomic waiting operation ([**atomics.wait**]).
</div>

<xmp>
void atomic_flag_notify_one(volatile atomic_flag* object) noexcept;
void atomic_flag_notify_one(atomic_flag* object) noexcept;
void atomic_flag::notify_one() volatile noexcept;
void atomic_flag::notify_one() noexcept;
</xmp>

<div class="numbered">
*Effects:* Unblocks the execution of at least one atomic waiting operation that is eligible to be unblocked ([**atomics.wait**]) by this call, if any such atomic waiting operations exist.
</div>

<div class="numbered">
*Remarks:* This function is an atomic notifying operation ([**atomics.wait**]).
</div>

<xmp>
void atomic_flag_notify_all(volatile atomic_flag* object) const noexcept;
void atomic_flag_notify_all(atomic_flag* object) const noexcept;
void atomic_flag::notify_all() volatile noexcept;
void atomic_flag::notify_all() noexcept;
</xmp>

<div class="numbered">
*Effects:* Unblocks the execution of all atomic waiting operations that are eligible to be unblocked ([**atomics.wait**]) by this call.
</div>

<div class="numbered">
*Remarks:* This function is an atomic notifying operation ([**atomics.wait**]).
</div>

</div>
</blockquote>

Modify Table 134 "Thread support library summary" in <a href="http://eel.is/c++draft/thread.general">[**thread.general**]</a> as follows:

<blockquote>
<div style="text-align: center;">
Table 134 — Thread support library summary
</div>
<table border=1 style="margin: auto;">
<tr>             <th></th>     <th>Subclause</th>            <th>Header(s)</th> </tr>
<tr>             <td>32.2</td> <td>Requirements</td>         <td></td> </tr>
<tr>             <td>32.3</td> <td>Threads</td>              <td>`<thread>`</td> </tr>
<tr>             <td>32.4</td> <td>Mutual exclusion</td>     <td>`<mutex>` `<shared_mutex>`</td> </tr>
<tr>             <td>32.5</td> <td>Condition variables</td>  <td>`<condition_variable>`</td> </tr>
<tr class="ins"> <td>32.�</td> <td>Semaphores</td>           <td>`<semaphore>`</td> </tr>
<tr class="ins"> <td>32.�</td> <td>Latches and barriers</td> <td>`<latch>` `<barrier>`</td> </tr>
<tr>             <td>32.6</td> <td>Futures</td>              <td>`<future>`</td> </tr>
</table>
</blockquote>

Add two new subclauses after <a href="http://eel.is/c++draft/thread.condition">[**thread.condition**]</a>:

<blockquote class="ins">
<b>32.� Semaphores <span style="float: right;">[thread.semaphore]</span></b>

<div class="numbered">
Semaphores are lightweight synchronization primitives used to constrain concurrent access to a shared resource. They are widely used to implement other synchronization primitives and, whenever both are applicable, can be more efficient than condition variables.
</div>

<div class="numbered">
A counting semaphore is a semaphore object that models a non-negative resource count. A binary semaphore is a semaphore object that has only two states. A binary semaphore should be more efficient than the default implementation of a counting semaphore with a unit resource count.
</div>
</blockquote>

<blockquote class="ins">
<b>32.�.1 Header `<semaphore>` synopsis <span style="float: right;">[thread.semaphore.syn]</span></b>

<pre><code>
namespace std {  
  template&lt;ptrdiff_t least_max_value = <i>implementation-defined</i>&gt;
    class counting_semaphore;

  using binary_semaphore = counting_semaphore&lt;1&gt;;
}
</code></pre>
</blockquote>

<blockquote class="ins">
<b>32.�.2 Class template `counting_semaphore` <span style="float: right;">[thread.semaphore.counting.class]</span></b>

<pre><code>
namespace std {
  template&lt;ptrdiff_t least_max_value = <i>implementation-defined</i>&gt;
  class counting_semaphore {
  public:
    static constexpr ptrdiff_t max() noexcept;

    constexpr explicit counting_semaphore(ptrdiff_t desired);
    ~counting_semaphore();

    counting_semaphore(const counting_semaphore&amp;) = delete;
    counting_semaphore&amp; operator=(const counting_semaphore&amp;) = delete;

    void release(ptrdiff_t update = 1);
    void acquire();
    bool try_acquire() noexcept;
    template&lt;class Rep, class Period&gt;
      bool try_acquire_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template&lt;class Clock, class Duration&gt;
      bool try_acquire_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);

  private:
    ptrdiff_t counter; <i>// exposition only</i>
  };
}
</code></pre>

<div class="numbered">
Class `counting_semaphore` maintains an internal counter that is initialized when the semaphore is created. The counter is decremented when a thread acquires the semaphore, and is incremented when a thread releases the semaphore.  If a thread tries to acquire the semaphore when the counter is zero, the thread will block until another thread increments the counter by releasing the semaphore.
</div>

<div class="numbered">
`least_max_value` shall be greater than zero; otherwise the program is ill-formed.
</div>

<div class="numbered">
Concurrent invocations of the member functions of `counting_semaphore`, other than its destructor, do not introduce data races.  The member functions `release` and `try_acquire` shall execute atomically.
</div>

```
static constexpr ptrdiff_t max() noexcept;
```

<div class="numbered">
*Returns:* The maximum value of `counter`. This value is greater than or equal to `least_max_value`.
</div>

```
constexpr explicit counting_semaphore(ptrdiff_t desired);
```

<div class="numbered">
*Expects:* `desired >= 0` is `true`, and `desired <= max()` is `true`.
</div>

<div class="numbered">
*Effects:* Initializes `counter` with `desired`.
</div>

<div class="numbered">
*Throws:* Nothing.
</div>

```
~counting_semaphore();
```

<div class="numbered">
*Expects:* For every function call blocked on `*this`, a function call that will cause it to unblock and return has happened before this call.
[ *Note:* This relaxes the usual rules, which would have required all blocking function calls to happen before destruction. — *end note* ]
</div>

``` 
void release(ptrdiff_t update = 1);
```

<div class="numbered">
*Expects:* `update >= 0` is `true`, and `update <= max() - counter` is `true`.
</div>

<div class="numbered">
*Effects:* Atomically execute `counter += update`. Then, unblock any threads that are waiting for `counter` to be greater than zero.
</div>

<div class="numbered">
*Synchronization:* Strongly happens before invocations of `try_acquire` that observe the result of the effects.
</div>

<!-- Based on std::mutex::lock wording -->
<div class="numbered">
*Throws:* `system_error` when an exception is required (<a href="http://eel.is/c++draft/thread.req.exception">[**thread.req.exception**]</a>).
</div>

<div class="numbered">
*Error conditions:* Any of the error conditions allowed for mutex types (<a href="http://eel.is/c++draft/thread.mutex.requirements.mutex">[**thread.mutex.requirements.mutex**]</a>).
</div>

```
bool try_acquire() noexcept;
```

<div class="numbered">
*Effects:*

  - With low probability, returns immediately. An implementation should ensure that `try_acquire` does not consistently return `false` in the absence of contending acquisitions.
  - Otherwise, if `counter` is greater than zero, atomically decrement `counter` by one.

</div>

<div class="numbered">
*Returns:* `true` if `counter` was decremented, otherwise `false`.
</div>

```
void acquire();
```

<div class="numbered">
*Effects:* Repeatedly performs the following steps, in order:

  - Evaluates `try_acquire`. If the result is `true`, returns. 
  - Blocks on `*this` until `counter` is greater than zero.

</div>

<!-- Based on std::mutex::lock wording -->
<div class="numbered">
*Throws:* `system_error` when an exception is required (<a href="http://eel.is/c++draft/thread.req.exception">[**thread.req.exception**]</a>).
</div>

<div class="numbered">
*Error conditions:* Any of the error conditions allowed for mutex types (<a href="http://eel.is/c++draft/thread.mutex.requirements.mutex">[**thread.mutex.requirements.mutex**]</a>).
</div>

```
template<class Rep, class Period>
  bool try_acquire_for(const chrono::duration<Rep, Period>& rel_time);
template<class Clock, class Duration>
  bool try_acquire_until(const chrono::time_point<Clock, Duration>& abs_time);
```

<div class="numbered">
*Effects:* Repeatedly performs the following steps, in order:

  - Evaluates `try_acquire`. If the result is `true`, returns `true`. 
  - Blocks on `*this` until `counter` is greater than zero or until the timeout expires.  If it is unblocked by the timeout expiring, returns `false`.

The timeout expires (<a href="http://eel.is/c++draft/thread.req.timing">[**thread.req.timing**]</a>)
when the current time is after `abs_time` (for `try_acquire_until`) or when at least
`rel_time` has passed from the start of the function (for `try_acquire_for`).
</div>

<!-- Based on std::timed_mutex::try_lock_for wording -->
<div class="numbered">
*Throws:* Timeout-related exceptions (<a href="http://eel.is/c++draft/thread.req.timing">[**thread.req.timing**]</a>), or `system_error` when a non-timeout-related exception is required (<a href="http://eel.is/c++draft/thread.req.exception">[**thread.req.exception**]</a>).
</div>

<div class="numbered">
*Error conditions:* Any of the error conditions allowed for mutex types (<a href="http://eel.is/c++draft/thread.mutex.requirements.mutex">[**thread.mutex.requirements.mutex**]</a>).
</div>
</blockquote>

<blockquote class="ins">
<b>32.� Coordination Types <span style="float: right;">[thread.coord]</span></b>

<div class="numbered">
This subclause describes various concepts related to thread coordination, and defines the coordination types `latch` and `barrier`. These types facilitate concurrent computation performed by a number of threads.
</div>
</blockquote>

<blockquote class="ins">
<b>32.�.1 Latches <span style="float: right;">[thread.coord.latch]</span></b>

<div class="numbered">
A latch is a thread coordination mechanism that allows any number of threads to block until an expected number of threads arrive at the latch (via the `count_down` function).  The expected count is set when the latch is created.  An individual latch is a single-use object; once the expected count has been reached, the latch cannot be reused.
</div>
</blockquote>

<blockquote class="ins">
<b>32.�.1.1 Header `<latch>` synopsis <span style="float: right;">[thread.coord.latch.syn]</span></b>

<xmp>
namespace std {
  class latch;
}
</xmp>
</blockquote>

<blockquote class="ins">
<b>32.�.1.2 Class `latch` <span style="float: right;">[thread.coord.latch.class]</span></b>

<pre><code>
namespace std {
  class latch {
  public:
    constexpr explicit latch(ptrdiff_t expected);
    ~latch();

    latch(const latch&amp;) = delete;
    latch&amp; operator=(const latch&amp;) = delete;
    
    void count_down(ptrdiff_t update = 1);
    bool try_wait() const noexcept;
    void wait() const;
    void arrive_and_wait(ptrdiff_t update = 1);

  private:
    ptrdiff_t counter; <i>// exposition only</i>
  };
} 
</code></pre>

<div class="numbered">
A `latch` maintains an internal counter that is initialized when the `latch` is created. Threads can block on the latch object, waiting for `counter` to be decremented to zero.
</div>

<div class="numbered">
Concurrent invocations of the member functions of `latch`, other than its destructor, do not introduce data races. The member functions `count_down` and `try_wait` shall execute atomically.
</div>

```
constexpr explicit latch(ptrdiff_t expected);
```

<div class="numbered">
*Expects:* `expected >= 0` is `true`.
</div>

<div class="numbered">
*Effects:* Initializes `counter` with `expected`.
</div>

<div class="numbered">
*Throws:* Nothing.
</div>

```
~latch();
```

<div class="numbered">
*Expects:* No threads are blocked on `*this`. [ *Note:* May be called even if some threads have not yet returned from invocations of `wait` on this object, provided that they are unblocked. This relaxes the usual rules, which would have required all blocking function calls to happen before destruction. - *end note* ]
</div>

<div class="numbered">
*Remarks:* The destructor may block until all threads have exited invocations of `wait` on this object.
</div>

```
void count_down(ptrdiff_t update = 1);
```

<div class="numbered">
*Expects:* `update >= 0` is `true`, and `update <= counter` is `true`.
</div>

<div class="numbered">
*Effects:* Atomically decrements `counter` by `update`.  If `counter` is equal to zero, unblocks all threads blocked on `*this`.
</div>

<div class="numbered">
*Synchronization:* Strongly happens before the returns from all calls that are unblocked.
</div>

<!-- Based on std::mutex::lock wording -->
<div class="numbered">
*Throws:* `system_error` when an exception is required (<a href="http://eel.is/c++draft/thread.req.exception">[**thread.req.exception**]</a>).
</div>

<div class="numbered">
*Error conditions:* Any of the error conditions allowed for mutex types (<a href="http://eel.is/c++draft/thread.mutex.requirements.mutex">[**thread.mutex.requirements.mutex**]</a>).
</div>

```
bool try_wait() const noexcept;
```

<div class="numbered">
*Returns:* With very low probability `false`.  Otherwise `counter == 0`.
</div>

```
void wait() const;
```

<div class="numbered">
*Effects:* If `counter` equals zero, returns immediately. Otherwise, blocks on `*this` until a call to `count_down` that decrements `counter` to zero.
</div>

<!-- Based on std::mutex::lock wording -->
<div class="numbered">
*Throws:* `system_error` when an exception is required (<a href="http://eel.is/c++draft/thread.req.exception">[**thread.req.exception**]</a>).
</div>

<div class="numbered">
*Error conditions:* Any of the error conditions allowed for mutex types (<a href="http://eel.is/c++draft/thread.mutex.requirements.mutex">[**thread.mutex.requirements.mutex**]</a>).
</div>

```
void arrive_and_wait(ptrdiff_t update = 1);
```

<div class="numbered">
*Effects:* Equivalent to:
<pre><code>
&nbsp; count_down(update);
  wait();
</code></pre>
</div>
</blockquote>

<blockquote class="ins">
<b>32.�.2 Barriers <span style="float: right;">[thread.coord.barrier]</span></b>

<div class="numbered">
A barrier is a thread coordination mechanism whose lifetime consists of a sequence of barrier phases, where each phase allows at most an expected number of threads to block until the expected number of threads arrive at the barrier.  [ *Note:* A barrier is useful for managing repeated tasks that are handled by multiple threads. - *end note* ]
</div>
</blockquote>

<blockquote class="ins">
<b>32.�.2.1 Header `<barrier>` synopsis <span style="float: right;">[thread.coord.barrier.syn]</span></b>

<pre><code>
namespace std {
  template&lt;class CompletionFunction = <i>see below</i>&gt;
    class barrier;
}
</code></pre>
</blockquote>

<blockquote class="ins">
<b>32.�.2.2 Class template `barrier` <span style="float: right;">[thread.coord.barrier.class]</span></b>

<pre><code>
namespace std {
  template&ltclass CompletionFunction = <i>see below</i>&gt;
  class barrier {
  public:
    using arrival_token = <i>see below</i>;

    constexpr explicit barrier(ptrdiff_t phase_count,
                               CompletionFunction f = CompletionFunction());

    ~barrier();

    barrier(const barrier&amp;) = delete;
    barrier&amp; operator=(const barrier&amp;) = delete;

    [[nodiscard]] arrival_token arrive(ptrdiff_t update = 1);
    void wait(arrival_token&& arrival) const;

    void arrive_and_wait();
    void arrive_and_drop();

  private:
    CompletionFunction completion; <i>// exposition only</i>
  };
}
</code></pre>

<div class="numbered">
Each <dfn>barrier phase</dfn> consists of the following steps:

  - The expected count is decremented by each call to `arrive` or `arrive_and_drop`.
  - When the expected count reaches zero, the phase completion step is run. For the specialization with the default value of the `CompletionFunction` template parameter, the completion step is run atomically as part of the call to `arrive` or `arrive_and_drop` that caused the expected count to reach zero. For other specializations, the completion step is run on one of the threads that arrived at the barrier during the phase.
  - When the completion step finishes, the expected count is reset to what was specified by the `expected` argument to the constructor, possibly adjusted by calls to `arrive_and_drop`, and the next phase starts.
</div>

<div class="numbered">
Each phase defines a <dfn>phase synchronization point</dfn>.  Threads that arrive at the barrier during the phase can block on the phase synchronization point by calling `wait`, and will remain blocked until the phase completion step is run.
</div>

<div class="numbered">
The <dfn>phase completion step</dfn> that is executed at the end of each phase has the following effects:

  - Invokes the completion function, equivalent to `completion()`.
  - Unblocks all threads that are blocked on the phase synchronization point.

The end of the completion step strongly happens before the returns from all calls that were unblocked by the completion step.  For specializations that do not have the default value of the `CompletionFunction` template parameter, the behavior is undefined if any of the `barrier` object's member functions other than `wait` are called while the completion step is in progress.
</div>

<div class="numbered">
Concurrent invocations of the member functions of `barrier`, other than its destructor, do not introduce data races. The member functions `arrive` and `arrive_and_drop` shall execute atomically.
</div>

<div class="numbered">
`CompletionFunction` shall meet the *Cpp17MoveConstructible* requirements (Table <a href="http://eel.is/c++draft/utility.arg.requirements#tab:moveconstructible">26</a>) and the *Cpp17Destructible* requirements (Table <a href="http://eel.is/c++draft/utility.arg.requirements#tab:destructible">30</a>). `is_nothrow_invocable_v<CompletionFunction&>` shall be `true`.
</div>

<div class="numbered">
The default value of the `CompletionFunction` template parameter is an unspecified type, such that, in addition to satisfying the requirements of `CompletionFunction`, it meets the *Cpp17DefaultConstructible* requirements (Table <a href="http://eel.is/c++draft/utility.arg.requirements#tab:defaultconstructible">25</a>) and `completion()` has no effects.
</div>

<div class="numbered">
`barrier::arrival_token` is an unspecified type, such that it meets the *Cpp17MoveConstructible* (Table <a href="http://eel.is/c++draft/utility.arg.requirements#tab:moveconstructible">26</a>), *Cpp17MoveAssignable* (Table <a href="http://eel.is/c++draft/utility.arg.requirements#tab:moveassignable">28</a>), and *Cpp17Destructible* (Table <a href="http://eel.is/c++draft/utility.arg.requirements#tab:destructible">30</a>) requirements.
</div>

```
constexpr explicit barrier(ptrdiff_t phase_count,
                           CompletionFunction f = CompletionFunction());
```

<div class="numbered">
*Expects:* `phase_count >= 0` is `true`.
</div>

<div class="numbered">
*Effects:* Sets both the initial expected count for each barrier phase and the current expected count for the first phase to `phase_count`.  Initializes `completion` with `std::move(f)`.  Starts the first phase. [ *Note:* If `phase_count` is `0` this object can only be destroyed. — *end note* ]
</div>

<!-- Based on std::function::function wording -->
<div class="numbered">
*Throws:* Any exception thrown by `CompletionFunction`'s move constructor.
</div>

```
~barrier();
```

<div class="numbered">
*Expects:* No threads are blocked at a phase synchronization point for any barrier phase of this object. [ *Note:* May be called even if some threads have not yet returned from invocations of `wait`, provided that they have unblocked. This relaxes the usual rules, which would have required all blocking function calls to happen before destruction. - *end note* ]
</div>

<div class="numbered">
*Remarks:* The destructor may block until all threads have exited invocations of `wait` on this object. 
</div>

```
[[nodiscard]] arrival_token arrive(ptrdiff_t update = 1);
```

<div class="numbered">
*Expects:* `update > 0` is `true`, and `update` is less than or equal to the expected count for the current barrier phase.
</div>

<div class="numbered">
*Effects:* Constructs an object of type `arrival_token` that is associated with the phase synchronization point for the current phase.  Then, decrements the expected count by `update`.
</div>

<div class="numbered">
*Synchronization:* The call to `arrive` strongly happens before the start of the phase completion step for the current phase.
</div>

<div class="numbered">
*Returns:* The constructed `arrival_token` object.
</div>

<!-- Based on std::mutex::lock wording -->
<div class="numbered">
*Throws:* `system_error` when an exception is required (<a href="http://eel.is/c++draft/thread.req.exception">[**thread.req.exception**]</a>).
</div>

<div class="numbered">
*Error conditions:* Any of the error conditions allowed for mutex types (<a href="http://eel.is/c++draft/thread.mutex.requirements.mutex">[**thread.mutex.requirements.mutex**]</a>).
</div>

<div class="numbered">
*Remarks:* This call can cause the completion step for the current phase to start.
</div>


```
void wait(arrival_token&& arrival) const;
```

<div class="numbered">
*Expects:* `arrival` is associated with the phase synchronization point for the current phase or the immediately preceding phase of the same barrier object.
</div>

<div class="numbered">
*Effects:* Blocks at the synchronization point associated with `std::move(arrival)` until the phase completion step of the synchronization point's phase is run. [ *Note:* If `arrival` is associated with the synchronization point for a previous phase, the call returns immediately. - *end note* ]
</div>

<!-- Based on std::mutex::lock wording -->
<div class="numbered">
*Throws:* `system_error` when an exception is required (<a href="http://eel.is/c++draft/thread.req.exception">[**thread.req.exception**]</a>).
</div>

<div class="numbered">
*Error conditions:* Any of the error conditions allowed for mutex types (<a href="http://eel.is/c++draft/thread.mutex.requirements.mutex">[**thread.mutex.requirements.mutex**]</a>).
</div>

```
void arrive_and_wait();
```

<div class="numbered">
*Effects:* Equivalent to: `wait(arrive())`.
</div>

``` 
void arrive_and_drop();
```

<div class="numbered">
*Expects:* The expected count for the current barrier phase is greater than zero. 
</div>

<div class="numbered">
*Effects:* Decrements the initial expected count for all subsequent phases by one.  Then decrements the expected count for the current phase by one.
</div>

<div class="numbered">
*Synchronization:* The call to `arrive_and_drop` strongly happens before the start of the phase completion step for the current phase.
</div>

<!-- Based on std::mutex::lock wording -->
<div class="numbered">
*Throws:* `system_error` when an exception is required (<a href="http://eel.is/c++draft/thread.req.exception">[**thread.req.exception**]</a>).
</div>

<div class="numbered">
*Error conditions:* Any of the error conditions allowed for mutex types (<a href="http://eel.is/c++draft/thread.mutex.requirements.mutex">[**thread.mutex.requirements.mutex**]</a>).
</div>

<div class="numbered">
*Remarks:* This call can cause the completion step for the current phase to start.
</div>
</blockquote>

Create the following feature test macros with the given headers, adding them to the table in [support.limits.general]:

  - `__cpp_lib_atomic_lock_free_type_aliases` in `<atomic>`, which implies that `atomic_signed_lock_free` and `atomic_unsigned_lock_free` types are available.
  - `__cpp_lib_atomic_flag_test` in `<atomic>`, which implies the `test` methods and free functions for `atomic_flag` are available.
  - `__cpp_lib_atomic_wait` in `<atomic>`, which implies the `wait`, `notify_one`, and `notify_all` methods and free functions for `atomic` and `atomic_flag` are available.
  - `__cpp_lib_semaphore` in `<semaphore>`, which implies that `counting_semaphore` and `binary_semaphore` are available.
  - `__cpp_lib_latch` in `<latch>`, which implies that `latch` is available.
  - `__cpp_lib_barrier` in `<barrier>`, which implies that `barrier` is available.

